[{"id":0,"blogId":1,"title":"title20","url":"blogDetail.html?blogId=1","content":"content"},{"id":1,"blogId":7,"title":"title2","url":"blogDetail.html?blogId=7","content":"# 线程安全是整个多线程中的要点\n什么是线程不安全：\n\n就是在编写多线程代码的时候，如果当前代码中因为多线程随机的调度顺序，导致程序出现bug，就称为线程不安全，反之就安全。\n\n一个常见的线程不安全的案例：\n```java\nclass Increase {\n    public int t = 0;\n    public void inc() {\n        t++;\n    }\n}\npublic class demo9 {\n    public static Increase increase = new Increase();\n    public static void main(String[] args) throws InterruptedException {\n        Thread t1 = new Thread(() -> {\n            for (int i = 0; i < 5000; i++) {\n                increase.inc();\n            }\n        });\n        Thread t2 = new Thread(() -> {\n            for (int i = 0; i < 5000; i++) {\n                increase.inc();\n            }\n        });\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n        System.out.println(increase.t);\n    }\n}\n\n```\n这里我们需要知道t++的原理，这个操作分为三个步骤，首先是从内存中将数据加载到cpu上，然后在cpu上进行加1操作，然后再放回内存中，这里的三个步骤不具有原子性，且进程会抢占执行，就会导致进程不安全。\n\n那这里如何使进程安全？？\n\n一个典型的方法就是加锁\n\n通过加锁操作，就可以把上诉的”无序“变为有序，把上诉的”随机“ 变为确定。\n\njava中给进程加锁的方式有很多，最常用的就是synchronized 这个关键字。\n\n这个关键字的意思是同步，也就是互斥。\n\n```java\nsynchronized public void inc() {\n    t++;\n}\n```\n这里只需要在inc这个函数上加上synchronized这个关键字，程序在进入这个函数的时候就会自动加上锁。此时结果就正确了。\n原因：如果当前锁是未被占用的情况，有一个线程t1尝试进行lock操作，t1就可以立即获取到锁，并且继续执行后面的逻辑。\n\n又有一个线程尝试进行lock操作，t2线程就只能等待（block状态），一直等待，直到t1线程释放，这个时候t2才能执行后续的操作\n\n引入多线程，就是为了实现并发编程（提高速度），但是当加了锁之后，数据结果是对了，但是这里的并发性实际上就降低了，速度也就下降了。"},{"id":2,"blogId":18,"title":"root first","url":"blogDetail.html?blogId=18","content":"# 在这里写下一篇博客\nroot:\"hello world\""}]